(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: google/protobuf/timestamp.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving compare, equal, hash, sexp, yojson]'
    opens=[Core; Ppx_yojson_conv_lib.Yojson_conv]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
open Core [@@warning "-33"]
open Ppx_yojson_conv_lib.Yojson_conv [@@warning "-33"]
module rec Timestamp : sig
  val name': unit -> string
  type t = { seconds: int; nanos: int } [@@deriving compare, equal, hash, sexp, yojson]
  val create : ?seconds:int -> ?nanos:int -> unit -> t
  val to_proto: t -> Runtime'.Writer.t
  val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) Stdlib.Result.t
  val to_time_ns : t -> Time_ns.t
  val of_time_ns : Time_ns.t -> t
end = struct 
  let name' () = ""
  type t = { seconds: int; nanos: int } [@@deriving compare, equal, hash, sexp, yojson]
  let create =
    fun ?seconds ?nanos () -> 
    let seconds = match seconds with Some v -> v | None -> 0 in
    let nanos = match nanos with Some v -> v | None -> 0 in
    { seconds; nanos }
  
  let to_proto =
    let apply = fun ~f:f' { seconds; nanos } -> f' [] seconds nanos in
    let spec = Runtime'.Serialize.C.( basic (1, int64_int, proto3) ^:: basic (2, int32_int, proto3) ^:: nil ) in
    let serialize = Runtime'.Serialize.serialize [] (spec) in
    fun t -> apply ~f:serialize t
  
  let from_proto =
    let constructor = fun _extensions seconds nanos -> { seconds; nanos } in
    let spec = Runtime'.Deserialize.C.( basic (1, int64_int, proto3) ^:: basic (2, int32_int, proto3) ^:: nil ) in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error

  let to_time_ns x =
    Time_ns.of_int_ns_since_epoch ((x.seconds * 1_000_000_000) + x.nanos)
  ;;

  let of_time_ns x =
    let ns = Time_ns.to_int_ns_since_epoch x in
    let seconds = ns / 1_000_000_000 in
    let nanos = ns mod 1_000_000_000 in
    create ~seconds ~nanos ()
  ;;

  let yojson_of_t t =
    `String (to_time_ns t |> Time_ns.to_string_iso8601_basic ~zone:Time_ns_unix.Zone.utc)

  let t_of_yojson json =
    Yojson.Safe.Util.to_string json |> Time_ns_unix.of_string |> of_time_ns
end
